<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>my devlog</title>
      <style>
      .code {
	     background-color : #666666;
	     border-radius: 25px;
	     padding: 20px;
	   }
      a:link {
        color: #F8F8F8; 
      }
      a:visited {
        color: #F8F8F8;
      }
    </style>
   </head>
   <body style ="color: #F8F8F8; background-color: #1C1C1C">
     <a href="/personal_homepage/index.html">Home</a>
     <hr />
      <div style="text-align: center;">
         <main style="display: inline-block; text-align: left">
           <h3> leet code Sunday! </h3>
           <a href="https://leetcode.com/problems/longest-mountain-in-array/"> Longest Mountain in Array</a>
           I do not leetcode very often, I am more into making some tools and games that I use.<br>
           Anyhow, I love solving puzzles and  I try to find and solve one or two interesting question every week.<br>
           The problem I solved today was about finding a subarray with a particular pattern in an array.<br>
           I did not want to go a whole array for each element in an array to find the "mountain array".
           It seemed like wasting because it visited the same elements over and over again.
           It took me some time coming with a decent solution which I myself was satisfied with. <br>
           But when I solved it finally at almost midnight on Sunday, it was very rewarding :) <br>
	   
	   <div class="code"><pre><code>
	   
//Runtime: 28 ms, faster than 69.57% of C online submissions for Longest Mountain in Array.
//Memory Usage: 6.6 MB, less than 65.22% of C online submissions for Longest Mountain in Array.

int longestMountain(int* arr, int arrSize){
    // return the length of the longest subarray which is a mountain
    // mountain length shoud be at least 3.
    if(arrSize < 3) {
        return 0;
    }
    int max_length = 0;
    int index = 0;
    int i = 0;
    int j = 1;
    
    while(j < arrSize - 1)
    {
        
        //a mountain starts from increasing numbers
        if(arr[i] >= arr[j])
        {
            i++;
            j++;
            continue;
        }
        //increasing number from here
        int mountain_length = 2;
        int increasing = 0;
        int decreasing = 0;
        //ascending
        while(j + 1 < arrSize && arr[j] < arr[j+1])
        {
            increasing++;
            ++j;
        }
        //descending
        while(j + 1 < arrSize && arr[j] > arr[j +1])
        {
            decreasing++;
            ++j;
        }
        // decreasing numbers is required
        if(decreasing > 0)
        {
            mountain_length += increasing + decreasing;
            if(mountain_length > max_length)
            {
                max_length = mountain_length;
            }                        
        }

        i = j;
        j = i + 1;        
    } 
    return max_length;
}
	   </code></pre></div>
         </main>
      </div>
   </body>
</html>
